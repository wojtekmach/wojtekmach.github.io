I"°1<p><a href="/blog/2012/07/17/liskov-principle-and-minitest/">Last time</a> I wrote about enforcing Liskov principle via tests. It was pretty simple to do in Minitest using just class inheritance. Sometimes, however, we can‚Äôt inherit test methods because the framework forces us to inherit from a test case class like:</p>

<ul>
  <li><code class="highlighter-rouge">ActiveSupport::TestCase</code></li>
  <li><code class="highlighter-rouge">ActionDispatch::IntegrationTest</code></li>
</ul>

<p>etc. In these cases we need to find some other way to share behavior and with Minitest‚Äôs design the answer is pretty simple - modules.</p>

<h2 id="example">Example</h2>

<p>Let‚Äôs write a simple data store library inspired by <a href="https://github.com/minad/moneta">Moneta</a></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DataStore</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span>
    <span class="vi">@adapter</span> <span class="o">=</span> <span class="n">adapter</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="vi">@adapter</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="vi">@adapter</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now let‚Äôs write an adapter:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DataStore::InMemoryAdapter</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@hash</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="vi">@hash</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="vi">@hash</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Let‚Äôs write a test for this. Knowing we will later reuse test methods, we start with a module:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">DataStore::AdapterTest</span>
  <span class="k">def</span> <span class="nf">test_get_not_found</span>
    <span class="n">assert_equal</span> <span class="kp">nil</span><span class="p">,</span> <span class="vi">@adapter</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">:invalid</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_set</span>
    <span class="vi">@adapter</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="ss">:foo</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
    <span class="n">assert_equal</span> <span class="mi">42</span><span class="p">,</span> <span class="vi">@adapter</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now the actual <code class="highlighter-rouge">DataStore::InMemoryAdapter</code> test (note, I‚Äôm using <code class="highlighter-rouge">Minitest::Test</code> which comes from minitest 5):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DataStore::InMemoryAdapterTest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span> 
  <span class="kp">include</span> <span class="no">DataStore</span><span class="o">::</span><span class="no">AdapterTest</span>

  <span class="k">def</span> <span class="nf">setup</span>
    <span class="vi">@adapter</span> <span class="o">=</span> <span class="no">DataStore</span><span class="o">::</span><span class="no">InMemoryAdapter</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Running this we see that two examples have been ‚Äúinherited‚Äù from the shared module:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~% ruby shared.rb
Run options: <span class="nt">--seed</span> 18221

<span class="c"># Running:</span>

..

Finished <span class="k">in </span>0.001126s, 1776.1989 runs/s, 1776.1989 assertions/s.

2 runs, 2 assertions, 0 failures, 0 errors, 0 skips
</code></pre></div></div>

<p>With this foundation it‚Äôs pretty easy to add new adapters and we don‚Äôt really have to write new tests. Including shared module in the test is enough to have confidence that an adapter is conforming to an interface.</p>

<p>Let‚Äôs say we package the data store as a gem. We can ship the <code class="highlighter-rouge">AdapterTest</code> as an integral part of the gem distribution and let the users write their own application specific adapters. Just as Rails ships with <code class="highlighter-rouge">ActionDsipatch::IntegrationTest</code>.</p>

<h2 id="minitestspec">minitest/spec</h2>

<p>It‚Äôs actually pretty easy to use shared modules with minitest/spec. It‚Äôs simple because minitest/spec is really just a DSL on top of minitest/test (minitest/unit). A <code class="highlighter-rouge">describe</code> block creates a new <code class="highlighter-rouge">Minitest::Test</code> class, an <code class="highlighter-rouge">it</code> block defines a new <code class="highlighter-rouge">test_</code> method. With this in mind we can start with our custom DSL like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">DataStore::AdapterSpec</span>
  <span class="n">it</span> <span class="s2">"returns nil for an invalid key"</span> <span class="k">do</span>
    <span class="vi">@adapter</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">:invalid</span><span class="p">).</span><span class="nf">must_equal</span> <span class="kp">nil</span>
  <span class="k">end</span>

  <span class="n">it</span> <span class="s2">"can set a value"</span> <span class="k">do</span>
    <span class="vi">@adapter</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="ss">:foo</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
    <span class="vi">@adapter</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">:foo</span><span class="p">).</span><span class="nf">must_equal</span> <span class="mi">42</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And the spec:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">describe</span> <span class="no">DataStore</span><span class="o">::</span><span class="no">InMemoryAdapter</span> <span class="k">do</span>
  <span class="kp">include</span> <span class="no">DataStore</span><span class="o">::</span><span class="no">AdapterSpec</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="vi">@adapter</span> <span class="o">=</span> <span class="no">DataStore</span><span class="o">::</span><span class="no">InMemoryAdapter</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Running this will result in error like:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;module:AdapterSpec&gt;: undefined method <span class="s1">'it'</span> <span class="k">for </span>DataStore::AdapterSpec:Module <span class="o">(</span>NoMethodError<span class="o">)</span>
</code></pre></div></div>

<p>Let‚Äôs fix this; we basically have to implement <code class="highlighter-rouge">Module#it</code> for it to work:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Module</span>
  <span class="k">def</span> <span class="nf">it</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">define_method</span> <span class="s2">"test_</span><span class="si">#{</span><span class="n">description</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Tests should be passing now.</p>

<p>I mentioned before that minitest/spec is just a DSL. In fact, there‚Äôs literally a <a href="https://github.com/seattlerb/minitest/blob/363ff3fe7c0144f6d02d04dabad9ceee5d252fa7/lib/minitest/spec.rb#L96">Minitest::Spec::DSL module</a> that <code class="highlighter-rouge">Minitest::Spec</code> is including. The DSL module is so good in fact that it can be included both in classes and in other modules:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Module</span>
  <span class="kp">include</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Spec</span><span class="o">::</span><span class="no">DSL</span>
<span class="k">end</span>
</code></pre></div></div>

<p>and it just works! We now can do stuff like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">SomeTest</span>
  <span class="n">before</span> <span class="p">{</span> <span class="s2">"..."</span> <span class="p">}</span>
  <span class="n">after</span> <span class="p">{</span> <span class="s2">"..."</span> <span class="p">}</span>

  <span class="n">let</span><span class="p">(</span><span class="ss">:foo</span><span class="p">)</span> <span class="p">{</span> <span class="s2">"..."</span> <span class="p">}</span>

  <span class="n">it</span> <span class="s2">"returns this"</span> <span class="k">do</span>
  <span class="k">end</span>

  <span class="n">it</span> <span class="s2">"returns that"</span> <span class="k">do</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>etc.</p>

<p>The way <code class="highlighter-rouge">Minitest::Spec::DSL</code> is implemented is actually pretty simple. It doesn‚Äôt do anything special; it just defines a bunch of methods like <code class="highlighter-rouge">setup</code>, <code class="highlighter-rouge">teardown</code>, <code class="highlighter-rouge">foo</code>, <code class="highlighter-rouge">test_returns_this</code> etc. It means that after the ‚ÄúDSL‚Äù phase we end up with just a ruby module that we can include (or not), and nothing is evaluated until the module is included somewhere.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Minitest‚Äôs simple design allows us to extend it with standard tools we use in day to day ruby programming. We can use the same exact constructs like classes, modules, inheritance &amp; mixins for both the production &amp; test code. As a consequence of this design writing minitest extensions is imho pretty easy too!</p>
:ET