I"óD<p><a href="/blog/2013/07/17/sharing-examples-in-minitest/">Last time</a> I wrote about sharing examples in Minitest. This time I want to show an idea I had for a long time about reusing the same test to verify systemâ€™s behavior on different levels.</p>

<p>Letâ€™s say weâ€™re building a simple signup application. We may end up with a test like this:</p>

<p>(Check out full code here: <a href="https://github.com/wojtekmach/signups">https://github.com/wojtekmach/signups</a>)</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SignupWebTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="k">def</span> <span class="nf">test_success</span>
    <span class="n">visit</span> <span class="s2">"/"</span>
    <span class="n">fill_in</span> <span class="s2">"Email"</span><span class="p">,</span> <span class="ss">with: </span><span class="s2">"example@gmail.com"</span>
    <span class="n">click_button</span> <span class="s2">"Sign up"</span>

    <span class="n">assert</span> <span class="n">page</span><span class="p">.</span><span class="nf">has_content?</span> <span class="s2">"Thanks!"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_failure</span>
    <span class="n">visit</span> <span class="s2">"/"</span>
    <span class="n">fill_in</span> <span class="s2">"Email"</span><span class="p">,</span> <span class="ss">with: </span><span class="s2">"invalid"</span>
    <span class="n">click_button</span> <span class="s2">"Sign up"</span>

    <span class="n">assert</span> <span class="n">signup</span><span class="p">.</span><span class="nf">has_content?</span> <span class="s2">"Email"</span> <span class="s2">"is invalid"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now, letâ€™s say we also want to have an API. Often times we are testing the same two scenarios as above, usually with the same test data:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SignupAPITest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="k">def</span> <span class="nf">test_success</span>
    <span class="n">post</span> <span class="s1">'/signup'</span><span class="p">,</span> <span class="ss">signup: </span><span class="p">{</span><span class="ss">email: </span><span class="s1">'example@gmail.com'</span><span class="p">}</span>
    <span class="n">assert</span> <span class="n">last_response</span><span class="p">.</span><span class="nf">succes?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_failure</span>
    <span class="n">post</span> <span class="s1">'/signup'</span><span class="p">,</span> <span class="ss">signup: </span><span class="p">{</span><span class="ss">email: </span><span class="s1">'invalid'</span><span class="p">}</span>
    <span class="n">refute</span> <span class="n">last_response</span><span class="p">.</span><span class="nf">succes?</span>
    <span class="n">assert_equal</span> <span class="no">Hash</span><span class="p">[</span><span class="s1">'email'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'is invalid'</span><span class="p">]],</span> <span class="no">JSON</span><span class="p">(</span><span class="n">last_response</span><span class="p">.</span><span class="nf">body</span><span class="p">)[</span><span class="s1">'errors'</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Finally, we also have the lower level test thatâ€™s using the application logic directly:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SignupTest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span>
  <span class="k">def</span> <span class="nf">test_success</span>
    <span class="n">signup</span> <span class="o">=</span> <span class="no">Signup</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'example@gmail.com'</span><span class="p">)</span>
    <span class="n">signup</span><span class="p">.</span><span class="nf">submit</span>
    <span class="n">assert</span> <span class="n">signup</span><span class="p">.</span><span class="nf">valid?</span>
    <span class="c1"># assert email was sent etc.</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_failure</span>
    <span class="n">signup</span> <span class="o">=</span> <span class="no">Signup</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'invalid'</span><span class="p">)</span>
    <span class="n">refute</span> <span class="n">signup</span><span class="p">.</span><span class="nf">valid?</span>
    <span class="n">assert_equal</span> <span class="no">Hash</span><span class="p">[</span><span class="ss">email: </span><span class="p">[</span><span class="s1">'is invalid'</span><span class="p">]],</span> <span class="n">signup</span><span class="p">.</span><span class="nf">errors</span><span class="p">.</span><span class="nf">messages</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We can extract the common part from all tests into helper methods like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SignupWebTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="k">def</span> <span class="nf">test_success</span>
    <span class="n">signup</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'example@gmail.com'</span><span class="p">)</span>
    <span class="n">assert</span> <span class="n">page</span><span class="p">.</span><span class="nf">has_content?</span> <span class="s2">"Thanks!"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_failure</span>
    <span class="n">signup</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'invalid'</span><span class="p">)</span>
    <span class="n">assert</span> <span class="n">signup</span><span class="p">.</span><span class="nf">has_content?</span> <span class="s2">"Email"</span> <span class="s2">"is invalid"</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">signup</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="n">visit</span> <span class="s2">"/"</span>
    <span class="n">fill_in</span> <span class="s2">"Email"</span><span class="p">,</span> <span class="ss">with: </span><span class="n">attributes</span><span class="p">[</span><span class="ss">:email</span><span class="p">]</span>
    <span class="n">click_button</span> <span class="s2">"Sign up"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">SignupAPITest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="k">def</span> <span class="nf">test_success</span>
    <span class="n">signup</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'example@gmail.com'</span><span class="p">)</span>
    <span class="n">assert</span> <span class="n">last_response</span><span class="p">.</span><span class="nf">succes?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_failure</span>
    <span class="n">signup</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'invalid'</span><span class="p">)</span>
    <span class="n">assert_equal</span> <span class="no">Hash</span><span class="p">[</span><span class="s1">'email'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'is invalid'</span><span class="p">]],</span> <span class="no">JSON</span><span class="p">(</span><span class="n">last_response</span><span class="p">.</span><span class="nf">body</span><span class="p">)[</span><span class="s1">'errors'</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">signup</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="n">post</span> <span class="s1">'/signup'</span><span class="p">,</span> <span class="ss">signup: </span><span class="n">attributes</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>As I am writing this, without thinking about it, I was just gonna work on cleaning up the 3rd test but, which is kind of the point of this post, there isnâ€™t anything to clean up there. Thereâ€™s no duplication thatâ€™s worth extracting out or some test/production API quirks worth hiding. Since we fully control the application code we can design it however we want.</p>

<p>This brings us back to the title of this post about reusing the same test on different levels. What I want to do is to design an interface that will behave like the <code class="highlighter-rouge">Signup</code> class, but under the hood will either call the application logic directly or use Web UI or API. The test must be written in such a way itâ€™s easy to inject dependencies.
Hereâ€™s one approach; I write it as a module that will be later included into concrete test cases.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">SignupTests</span>
  <span class="k">def</span> <span class="nf">test_success</span>
    <span class="n">signup</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">signup</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'example@gmail.com'</span><span class="p">).</span><span class="nf">submit</span>
    <span class="n">assert</span> <span class="n">signup</span><span class="p">.</span><span class="nf">valid?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_failure</span>
    <span class="n">signup</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">signup</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'invalid'</span><span class="p">).</span><span class="nf">submit</span>
    <span class="n">assert</span> <span class="o">!</span><span class="n">signup</span><span class="p">.</span><span class="nf">valid?</span>
    <span class="n">assert_equal</span> <span class="no">Hash</span><span class="p">[</span><span class="ss">email: </span><span class="p">[</span><span class="s1">'is invalid'</span><span class="p">]],</span> <span class="n">signup</span><span class="p">.</span><span class="nf">error_messages</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Whatâ€™s an <code class="highlighter-rouge">@app</code>? Itâ€™s an <em>object</em> that knows how to construct <em>object</em> that can play a role of a <code class="highlighter-rouge">Signup</code>. Object that can play role of <code class="highlighter-rouge">@app</code> need only to implement <code class="highlighter-rouge">#signup</code> <em>message</em>. For <code class="highlighter-rouge">Signup</code> <em>role</em> they need <code class="highlighter-rouge">#submit</code>, <code class="highlighter-rouge">#valid?</code> and <code class="highlighter-rouge">#error_messages</code>. Here are possible implementations:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class WebClient
  def signup(attributes)
    Signup.new(attributes)
  end

  class Signup
    include Capybara::DSL

    def initialize(attributes)
      @email = attributes[:email]
    end

    def submit
      visit '/'
      fill_in 'Email', with: @email
    end

    def valid?
      page.has_content? "Thanks!"
    end

    # ...
  end
end

class APIClient
  def initialize(base_uri)
    @base_uri = base_uri
  end

  def signup(attributes)
    Signup.new(self, attributes)
  end

  class Signup
    def initialize(client, attributes)
      @client, @attributes = client, attributes
    end

    def submit
      RestClient.post(@client.base_uri + "/signup", signup: @attributes)
      # ...
    end

    # ...
  end
end

class App
  def signup(attributes)
    Signup.new(attributes)
  end
end
</code></pre></div></div>

<p>Now we can write the remaining concrete test cases:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SignupAppTest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span>
  <span class="kp">include</span> <span class="no">SignupTests</span>

  <span class="k">def</span> <span class="nf">setup</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="no">App</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">SignupAPITest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span>
  <span class="kp">include</span> <span class="no">SignupTests</span>

  <span class="k">def</span> <span class="nf">setup</span>
    <span class="no">WebMock</span><span class="p">.</span><span class="nf">stub_request</span><span class="p">(</span><span class="ss">:any</span><span class="p">,</span> <span class="sr">/signup.test/</span><span class="p">).</span><span class="nf">to_rack</span><span class="p">(</span><span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">routes</span><span class="p">)</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="no">APIClient</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'http://signup.test'</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">SignupWebTest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span>
  <span class="kp">include</span> <span class="no">SignupTests</span>

  <span class="k">def</span> <span class="nf">setup</span>
    <span class="no">Capybara</span><span class="p">.</span><span class="nf">app</span> <span class="o">=</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="no">WebClient</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Thereâ€™s a few nice benefits about this design.</p>

<p>For one thing this setup is highly configurable. We can easily switch certain levels on and off. Whatâ€™s more, we can take this configuration further and for the UI &amp; API tests point them to live servers (e.g. staging.example.com) instead of local servers on development machine. This has added benefit that we can find more errors this way, like for example asset pipeline &amp; general deployment issues, DNS etc. Granted, this works extremely well for a simple application as such thatâ€™s basically stateless but it should still be doable for more complex cases.</p>

<p>This test design also forced us to write mostly production (albeit not used by the production app) code and just a little bit of simple test code. A nice side effect of this is I think youâ€™d generally keep this code more organized if itâ€™s not a part of the test suite. More importantly though as a way of testing the app we built client libraries to access API (See <a href="http://robots.thoughtbot.com/how-to-test-sinatra-based-web-services">http://robots.thoughtbot.com/how-to-test-sinatra-based-web-services</a>) and the Web UI. If youâ€™re lucky enough to have a dedicated QA team they may appreciate that they can drive the app using quite convenient interface yet still be able to access raw features of capybara etc.</p>

<p>Finally, thereâ€™s one more thing maybe worth mentioning. If we have 2 instances of the app running on <code class="highlighter-rouge">app1.example.com</code> and <code class="highlighter-rouge">app2.example.com</code> itâ€™s entirely possible to configure <code class="highlighter-rouge">app1</code>â€™s controllers to use <code class="highlighter-rouge">APIClient</code> (instead of simply <code class="highlighter-rouge">App</code>) pointed to <code class="highlighter-rouge">app2.example.com</code> without a single change in the application code. Again, probably not that useful but I think itâ€™s pretty cool :-)</p>
:ET