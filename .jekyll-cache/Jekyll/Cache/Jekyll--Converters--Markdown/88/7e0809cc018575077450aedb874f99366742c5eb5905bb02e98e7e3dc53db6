I"é*<p><a href="/blog/2014/07/17/integration-testing-on-different-levels/">Last time</a> I wrote about integration testing on different levels and in this post I want to explore topic that‚Äôs somewhat related to integration testing.</p>

<p>When testing code that integrates with DBs and JSON APIs I often find myself only caring about (and wanting to test) a subset of data. To give a concrete example, let‚Äôs say we‚Äôre integration testing a simple Rails controller with <code class="highlighter-rouge">/items</code> endpoint.</p>

<p>The simplest possible test for that could be just:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_create</span>
  <span class="no">Item</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"Item 1"</span><span class="p">)</span>
  <span class="no">Item</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"Item 2"</span><span class="p">)</span>

  <span class="n">get</span> <span class="s2">"/items"</span>

  <span class="n">assert_equal</span> <span class="p">[</span>
    <span class="p">{</span><span class="s2">"id"</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">"name"</span> <span class="o">=&gt;</span> <span class="s2">"Item 1"</span><span class="p">},</span>
    <span class="p">{</span><span class="s2">"id"</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">"name"</span> <span class="o">=&gt;</span> <span class="s2">"Item 2"</span><span class="p">},</span>
  <span class="p">],</span> <span class="no">JSON</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="nf">body</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>There‚Äôs a problem with this test and it‚Äôs the hardcoded ids (this is even more painful with things like <code class="highlighter-rouge">created_at</code>). This can be pretty easily solved by introducing local variables:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_create</span>
  <span class="n">item1</span> <span class="o">=</span> <span class="no">Item</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"Item 1"</span><span class="p">)</span>
  <span class="n">item2</span> <span class="o">=</span> <span class="no">Item</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"Item 2"</span><span class="p">)</span>

  <span class="n">get</span> <span class="s2">"/items"</span>

  <span class="n">assert_equal</span> <span class="p">[</span>
    <span class="p">{</span><span class="s2">"id"</span> <span class="o">=&gt;</span> <span class="n">item1</span><span class="p">.</span><span class="nf">id</span><span class="p">,</span> <span class="s2">"name"</span> <span class="o">=&gt;</span> <span class="s2">"Item 1"</span><span class="p">},</span>
    <span class="p">{</span><span class="s2">"id"</span> <span class="o">=&gt;</span> <span class="n">item2</span><span class="p">.</span><span class="nf">id</span><span class="p">,</span> <span class="s2">"name"</span> <span class="o">=&gt;</span> <span class="s2">"Item 2"</span><span class="p">},</span>
  <span class="p">],</span> <span class="no">JSON</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="nf">body</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>However, I think this introduced some complexity into the test code and decreased readability a bit. Also, I don‚Äôt really care what are the ids that have been auto-generated by my DB. My <strong>intent</strong> is to test the <code class="highlighter-rouge">name</code> attribute was correctly saved, and the <code class="highlighter-rouge">id</code> attribute is just an accidental detail.</p>

<p>Another way of addressing this problem is introducing even more complexity into the test code, by extracting only the fields I care about:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def test_create
  item1 = Item.create!(name: "Item 1")
  item2 = Item.create!(name: "Item 2")

  get "/items"

  assert_equal [
    "Item 1", "Item 2",
  ], JSON(response.body).map { |h| h['name'] }
end
</code></pre></div></div>

<p>However, I think this is really hard to read. Moreover, when this test grows I‚Äôd be concerned about a possibility of introducing a bug in my <em>test code</em>.</p>

<p>As mentioned above, my intent is to test the <code class="highlighter-rouge">name</code> attribute and I don‚Äôt really care what‚Äôs the <code class="highlighter-rouge">id</code> attribute - it can be <strong>any</strong> integer, as far as I‚Äôm concerned in this test. This is the test I‚Äôd like to write:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_create</span>
  <span class="n">item1</span> <span class="o">=</span> <span class="no">Item</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"Item 1"</span><span class="p">)</span>
  <span class="n">item2</span> <span class="o">=</span> <span class="no">Item</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"Item 2"</span><span class="p">)</span>

  <span class="n">get</span> <span class="s2">"/items"</span>

  <span class="n">assert_equal</span> <span class="p">[</span>
    <span class="p">{</span><span class="s2">"id"</span> <span class="o">=&gt;</span> <span class="n">any_integer</span><span class="p">,</span> <span class="s2">"name"</span> <span class="o">=&gt;</span> <span class="s2">"Item 1"</span><span class="p">},</span>
    <span class="p">{</span><span class="s2">"id"</span> <span class="o">=&gt;</span> <span class="n">any_integer</span><span class="p">,</span> <span class="s2">"name"</span> <span class="o">=&gt;</span> <span class="s2">"Item 2"</span><span class="p">},</span>
  <span class="p">],</span> <span class="no">JSON</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="nf">body</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>and let me show you how this can be achieved.</p>

<h2 id="building-any_integer">Building <code class="highlighter-rouge">any_integer</code></h2>

<p>Let‚Äôs break down the test above into the simplest possible code we could discuss. It boils down to:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assert_equal</span> <span class="p">[</span><span class="n">any_integer</span><span class="p">,</span> <span class="n">any_integer</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<p>Minitest‚Äôs <code class="highlighter-rouge">assert_equal</code> uses Ruby‚Äôs equality operator <code class="highlighter-rouge">==</code> to do the comparison. In this case, we‚Äôre equaling two <code class="highlighter-rouge">Array</code>s and <a href="http://ruby-doc.org/core-2.2.0/Array.html#method-i-3D-3D">per documentation</a> ‚ÄúTwo arrays are equal if they contain the same number of elements and if each element is equal to (according to Object#==)‚Äù</p>

<p>So, all we need to do is to implement the <code class="highlighter-rouge">==</code> method on the <code class="highlighter-rouge">any_integer</code> object:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AnyInteger</span>
  <span class="k">def</span> <span class="nf">==</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="n">other</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Integer</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="k">def</span> <span class="nf">any_integer</span>
  <span class="no">AnyInteger</span><span class="p">.</span><span class="nf">new</span>
<span class="k">end</span>

<span class="p">[</span><span class="n">any_integer</span><span class="p">,</span> <span class="n">any_integer</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>    <span class="c1"># =&gt; true</span>
<span class="p">[</span><span class="n">any_integer</span><span class="p">,</span> <span class="n">any_integer</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="ss">:bad</span><span class="p">]</span> <span class="c1"># =&gt; false</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">any_integer</code> and many other methods (as well as ways to <em>compose</em> them) is available on GitHub: <a href="https://github.com/wojtekmach/anything">https://github.com/wojtekmach/anything</a>, <a href="https://github.com/wojtekmach/anything/blob/master/test/anything_test.rb">https://github.com/wojtekmach/anything/blob/master/test/anything_test.rb</a></p>

<h2 id="conclusion">Conclusion</h2>

<p>In this post I described a different approach to testing data structures where in some cases the exact value isn‚Äôt as important as long as some property of that value is being checked. One could say that testing for type (and not for actual value) is kind of weak and languages with static types are solving this ‚Äúby design‚Äù and I tend to agree. However, what I‚Äôm trying to show here is testing for ‚Äúshape‚Äù of data (which is very useful in JSON APIs) and avoiding adding complexity in test code by extracting only a subset of attributes that matter. I was inspired by ideas from property-based testing to write this blog post, but I‚Äôm not sure people would say these two techniques are related. If anything, one could say that instead of bringing the best of both worlds (exact values from example-based testing and checking properties against random data from propert-based testing) I‚Äôm showing the worst of both worlds :-) Let me know what you think in the comments!</p>
:ET