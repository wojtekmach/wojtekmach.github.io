<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Integration testing on different levels | Wojtek Mach</title>
<meta name="generator" content="Jekyll v4.0.1" />
<meta property="og:title" content="Integration testing on different levels" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Last time I wrote about sharing examples in Minitest. This time I want to show an idea I had for a long time about reusing the same test to verify system’s behavior on different levels." />
<meta property="og:description" content="Last time I wrote about sharing examples in Minitest. This time I want to show an idea I had for a long time about reusing the same test to verify system’s behavior on different levels." />
<link rel="canonical" href="http://localhost:4000/blog/2014/07/17/integration-testing-on-different-levels/" />
<meta property="og:url" content="http://localhost:4000/blog/2014/07/17/integration-testing-on-different-levels/" />
<meta property="og:site_name" content="Wojtek Mach" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-07-17T23:17:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Integration testing on different levels" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Integration testing on different levels","dateModified":"2014-07-17T23:17:00+02:00","datePublished":"2014-07-17T23:17:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2014/07/17/integration-testing-on-different-levels/"},"description":"Last time I wrote about sharing examples in Minitest. This time I want to show an idea I had for a long time about reusing the same test to verify system’s behavior on different levels.","url":"http://localhost:4000/blog/2014/07/17/integration-testing-on-different-levels/","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Wojtek Mach" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Wojtek Mach</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Integration testing on different levels</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2014-07-17T23:17:00+02:00" itemprop="datePublished">Jul 17, 2014
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="/blog/2013/07/17/sharing-examples-in-minitest/">Last time</a> I wrote about sharing examples in Minitest. This time I want to show an idea I had for a long time about reusing the same test to verify system’s behavior on different levels.</p>

<p>Let’s say we’re building a simple signup application. We may end up with a test like this:</p>

<p>(Check out full code here: <a href="https://github.com/wojtekmach/signups">https://github.com/wojtekmach/signups</a>)</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SignupWebTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="k">def</span> <span class="nf">test_success</span>
    <span class="n">visit</span> <span class="s2">"/"</span>
    <span class="n">fill_in</span> <span class="s2">"Email"</span><span class="p">,</span> <span class="ss">with: </span><span class="s2">"example@gmail.com"</span>
    <span class="n">click_button</span> <span class="s2">"Sign up"</span>

    <span class="n">assert</span> <span class="n">page</span><span class="p">.</span><span class="nf">has_content?</span> <span class="s2">"Thanks!"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_failure</span>
    <span class="n">visit</span> <span class="s2">"/"</span>
    <span class="n">fill_in</span> <span class="s2">"Email"</span><span class="p">,</span> <span class="ss">with: </span><span class="s2">"invalid"</span>
    <span class="n">click_button</span> <span class="s2">"Sign up"</span>

    <span class="n">assert</span> <span class="n">signup</span><span class="p">.</span><span class="nf">has_content?</span> <span class="s2">"Email"</span> <span class="s2">"is invalid"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now, let’s say we also want to have an API. Often times we are testing the same two scenarios as above, usually with the same test data:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SignupAPITest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="k">def</span> <span class="nf">test_success</span>
    <span class="n">post</span> <span class="s1">'/signup'</span><span class="p">,</span> <span class="ss">signup: </span><span class="p">{</span><span class="ss">email: </span><span class="s1">'example@gmail.com'</span><span class="p">}</span>
    <span class="n">assert</span> <span class="n">last_response</span><span class="p">.</span><span class="nf">succes?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_failure</span>
    <span class="n">post</span> <span class="s1">'/signup'</span><span class="p">,</span> <span class="ss">signup: </span><span class="p">{</span><span class="ss">email: </span><span class="s1">'invalid'</span><span class="p">}</span>
    <span class="n">refute</span> <span class="n">last_response</span><span class="p">.</span><span class="nf">succes?</span>
    <span class="n">assert_equal</span> <span class="no">Hash</span><span class="p">[</span><span class="s1">'email'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'is invalid'</span><span class="p">]],</span> <span class="no">JSON</span><span class="p">(</span><span class="n">last_response</span><span class="p">.</span><span class="nf">body</span><span class="p">)[</span><span class="s1">'errors'</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Finally, we also have the lower level test that’s using the application logic directly:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SignupTest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span>
  <span class="k">def</span> <span class="nf">test_success</span>
    <span class="n">signup</span> <span class="o">=</span> <span class="no">Signup</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'example@gmail.com'</span><span class="p">)</span>
    <span class="n">signup</span><span class="p">.</span><span class="nf">submit</span>
    <span class="n">assert</span> <span class="n">signup</span><span class="p">.</span><span class="nf">valid?</span>
    <span class="c1"># assert email was sent etc.</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_failure</span>
    <span class="n">signup</span> <span class="o">=</span> <span class="no">Signup</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'invalid'</span><span class="p">)</span>
    <span class="n">refute</span> <span class="n">signup</span><span class="p">.</span><span class="nf">valid?</span>
    <span class="n">assert_equal</span> <span class="no">Hash</span><span class="p">[</span><span class="ss">email: </span><span class="p">[</span><span class="s1">'is invalid'</span><span class="p">]],</span> <span class="n">signup</span><span class="p">.</span><span class="nf">errors</span><span class="p">.</span><span class="nf">messages</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We can extract the common part from all tests into helper methods like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SignupWebTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="k">def</span> <span class="nf">test_success</span>
    <span class="n">signup</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'example@gmail.com'</span><span class="p">)</span>
    <span class="n">assert</span> <span class="n">page</span><span class="p">.</span><span class="nf">has_content?</span> <span class="s2">"Thanks!"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_failure</span>
    <span class="n">signup</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'invalid'</span><span class="p">)</span>
    <span class="n">assert</span> <span class="n">signup</span><span class="p">.</span><span class="nf">has_content?</span> <span class="s2">"Email"</span> <span class="s2">"is invalid"</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">signup</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="n">visit</span> <span class="s2">"/"</span>
    <span class="n">fill_in</span> <span class="s2">"Email"</span><span class="p">,</span> <span class="ss">with: </span><span class="n">attributes</span><span class="p">[</span><span class="ss">:email</span><span class="p">]</span>
    <span class="n">click_button</span> <span class="s2">"Sign up"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">SignupAPITest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="k">def</span> <span class="nf">test_success</span>
    <span class="n">signup</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'example@gmail.com'</span><span class="p">)</span>
    <span class="n">assert</span> <span class="n">last_response</span><span class="p">.</span><span class="nf">succes?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_failure</span>
    <span class="n">signup</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'invalid'</span><span class="p">)</span>
    <span class="n">assert_equal</span> <span class="no">Hash</span><span class="p">[</span><span class="s1">'email'</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'is invalid'</span><span class="p">]],</span> <span class="no">JSON</span><span class="p">(</span><span class="n">last_response</span><span class="p">.</span><span class="nf">body</span><span class="p">)[</span><span class="s1">'errors'</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">signup</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="n">post</span> <span class="s1">'/signup'</span><span class="p">,</span> <span class="ss">signup: </span><span class="n">attributes</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>As I am writing this, without thinking about it, I was just gonna work on cleaning up the 3rd test but, which is kind of the point of this post, there isn’t anything to clean up there. There’s no duplication that’s worth extracting out or some test/production API quirks worth hiding. Since we fully control the application code we can design it however we want.</p>

<p>This brings us back to the title of this post about reusing the same test on different levels. What I want to do is to design an interface that will behave like the <code class="highlighter-rouge">Signup</code> class, but under the hood will either call the application logic directly or use Web UI or API. The test must be written in such a way it’s easy to inject dependencies.
Here’s one approach; I write it as a module that will be later included into concrete test cases.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">SignupTests</span>
  <span class="k">def</span> <span class="nf">test_success</span>
    <span class="n">signup</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">signup</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'example@gmail.com'</span><span class="p">).</span><span class="nf">submit</span>
    <span class="n">assert</span> <span class="n">signup</span><span class="p">.</span><span class="nf">valid?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_failure</span>
    <span class="n">signup</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">signup</span><span class="p">(</span><span class="ss">email: </span><span class="s1">'invalid'</span><span class="p">).</span><span class="nf">submit</span>
    <span class="n">assert</span> <span class="o">!</span><span class="n">signup</span><span class="p">.</span><span class="nf">valid?</span>
    <span class="n">assert_equal</span> <span class="no">Hash</span><span class="p">[</span><span class="ss">email: </span><span class="p">[</span><span class="s1">'is invalid'</span><span class="p">]],</span> <span class="n">signup</span><span class="p">.</span><span class="nf">error_messages</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>What’s an <code class="highlighter-rouge">@app</code>? It’s an <em>object</em> that knows how to construct <em>object</em> that can play a role of a <code class="highlighter-rouge">Signup</code>. Object that can play role of <code class="highlighter-rouge">@app</code> need only to implement <code class="highlighter-rouge">#signup</code> <em>message</em>. For <code class="highlighter-rouge">Signup</code> <em>role</em> they need <code class="highlighter-rouge">#submit</code>, <code class="highlighter-rouge">#valid?</code> and <code class="highlighter-rouge">#error_messages</code>. Here are possible implementations:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class WebClient
  def signup(attributes)
    Signup.new(attributes)
  end

  class Signup
    include Capybara::DSL

    def initialize(attributes)
      @email = attributes[:email]
    end

    def submit
      visit '/'
      fill_in 'Email', with: @email
    end

    def valid?
      page.has_content? "Thanks!"
    end

    # ...
  end
end

class APIClient
  def initialize(base_uri)
    @base_uri = base_uri
  end

  def signup(attributes)
    Signup.new(self, attributes)
  end

  class Signup
    def initialize(client, attributes)
      @client, @attributes = client, attributes
    end

    def submit
      RestClient.post(@client.base_uri + "/signup", signup: @attributes)
      # ...
    end

    # ...
  end
end

class App
  def signup(attributes)
    Signup.new(attributes)
  end
end
</code></pre></div></div>

<p>Now we can write the remaining concrete test cases:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SignupAppTest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span>
  <span class="kp">include</span> <span class="no">SignupTests</span>

  <span class="k">def</span> <span class="nf">setup</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="no">App</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">SignupAPITest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span>
  <span class="kp">include</span> <span class="no">SignupTests</span>

  <span class="k">def</span> <span class="nf">setup</span>
    <span class="no">WebMock</span><span class="p">.</span><span class="nf">stub_request</span><span class="p">(</span><span class="ss">:any</span><span class="p">,</span> <span class="sr">/signup.test/</span><span class="p">).</span><span class="nf">to_rack</span><span class="p">(</span><span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">routes</span><span class="p">)</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="no">APIClient</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s1">'http://signup.test'</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">SignupWebTest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span>
  <span class="kp">include</span> <span class="no">SignupTests</span>

  <span class="k">def</span> <span class="nf">setup</span>
    <span class="no">Capybara</span><span class="p">.</span><span class="nf">app</span> <span class="o">=</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="no">WebClient</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>There’s a few nice benefits about this design.</p>

<p>For one thing this setup is highly configurable. We can easily switch certain levels on and off. What’s more, we can take this configuration further and for the UI &amp; API tests point them to live servers (e.g. staging.example.com) instead of local servers on development machine. This has added benefit that we can find more errors this way, like for example asset pipeline &amp; general deployment issues, DNS etc. Granted, this works extremely well for a simple application as such that’s basically stateless but it should still be doable for more complex cases.</p>

<p>This test design also forced us to write mostly production (albeit not used by the production app) code and just a little bit of simple test code. A nice side effect of this is I think you’d generally keep this code more organized if it’s not a part of the test suite. More importantly though as a way of testing the app we built client libraries to access API (See <a href="http://robots.thoughtbot.com/how-to-test-sinatra-based-web-services">http://robots.thoughtbot.com/how-to-test-sinatra-based-web-services</a>) and the Web UI. If you’re lucky enough to have a dedicated QA team they may appreciate that they can drive the app using quite convenient interface yet still be able to access raw features of capybara etc.</p>

<p>Finally, there’s one more thing maybe worth mentioning. If we have 2 instances of the app running on <code class="highlighter-rouge">app1.example.com</code> and <code class="highlighter-rouge">app2.example.com</code> it’s entirely possible to configure <code class="highlighter-rouge">app1</code>’s controllers to use <code class="highlighter-rouge">APIClient</code> (instead of simply <code class="highlighter-rouge">App</code>) pointed to <code class="highlighter-rouge">app2.example.com</code> without a single change in the application code. Again, probably not that useful but I think it’s pretty cool :-)</p>

  </div><a class="u-url" href="/blog/2014/07/17/integration-testing-on-different-levels/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        Copyright &copy; 2021 Wojtek Mach.
      </div>

      <div class="footer-col footer-col-1"><ul class="social-media-list"><li><a href="https://github.com/wojtekmach"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wojtekmach</span></a></li><li><a href="https://www.twitter.com/wojtekmach"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wojtekmach</span></a></li></ul>
</div>
    </div>

  </div>

</footer>
</body>

</html>
